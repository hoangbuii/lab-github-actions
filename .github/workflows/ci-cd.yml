name: Continous Integration + Continous Delivery Pipeline
# on:
#   push:
#     branches:
#       - master
#   pull_request:
#     branches:
#       - master

on:
  push:
    branches:
      - '**'

env:
  DOCKER_IMAGE: ${{ secrets.DOCKER_USERNAME }}/flask-app
  DOCKER_NETWORK: flask-net
  DOCKER_CONTAINER_NAME: flask-app


jobs:
  build:
    runs-on: self-hosted

    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Looking for user
        run: |
          whoami
      - name: Login to Docker hub
        run: |
          echo "${{ secrets.DOCKER_PASSWORD }}" | sudo docker login -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin

      # Build the Docker image (add check user)
      - name: Build Docker image
        run: |
          sudo docker build -t ${{ env.DOCKER_IMAGE }}:${{ github.sha }} .
  
  test:
    runs-on: self-hosted
    needs: build
    steps:
      
      # Run 2 image is flask-app and redis database
      - name: Set up containerizated app
        run: |
          sudo docker network create ${{ env.DOCKER_NETWORK }}
          sudo docker run -d --name redis -p 6379:6379 -v redis:/data --network ${{ env.DOCKER_NETWORK }} --network-alias redis redis:alpine
          sudo docker run -d --name ${{ env.DOCKER_CONTAINER_NAME }} -p 8080:8080 -e FLASK_APP=${{ secrets.FLASK_APP }} -e FLASK_DEBUG=${{ secrets.FLASK_DEBUG }} -e GUNICORN_BIND=${{ secrets.GUNICORN_BIND }} -e PORT=${{ secrets.PORT }} -e DATABASE_URI=${{ secrets.DATABASE_URI }} --network ${{ env.DOCKER_NETWORK }} ${{ env.DOCKER_IMAGE }}:${{ github.sha }}

      - name: Run unit tests with PyTest
        run: |
          sudo docker exec ${{ env.DOCKER_CONTAINER_NAME }} poetry run pytest --pspec --cov=service --cov-fail-under=95

  # push:
  #   runs-on: self-hosted
  #   needs: test
  #   steps:
  #     - name: Login to Docker hub
  #       run: |
  #         echo "${{ secrets.DOCKER_PASSWORD }}" | sudo docker login -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin
  #     - name: Push to Dockerhub
  #       run: |
  #         sudo docker push ${{ env.DOCKER_IMAGE }}

  clean:
    needs: [test]
    runs-on: self-hosted
    steps:
      - name: Remove all Containers
        run: |
          sudo docker rm -vf ${{ env.DOCKER_CONTAINER_NAME }}
          sudo docker rm -vf redis
      
      - name: Remove all Database Images
        run: |
          # sudo docker image rm ${{ env.DOCKER_IMAGE }}
          sudo docker image rm $(sudo docker image ls | grep "redis" | awk '{print $3}')

      - name: Remove Docker Network
        run: |
          sudo docker network rm ${{ env.DOCKER_NETWORK }}

  

  # deploy-to-staging:
  #   needs: push
  #   runs-on: self-hosted
  #   environment:
  #     name: staging
  #     url: http://ec2-54-254-129-220.ap-southeast-1.compute.amazonaws.com:9090
  #   steps:
  #     # - name: SSH to staging server
  #     #   run: |
 

  #     - name: Login to Docker hub
  #       run: |
  #         ssh ${{ secrets.STAGING_USER }}@${{ secrets.STAGING_IP_ADDR }} 'echo "${{ secrets.DOCKER_PASSWORD }}" | sudo docker login -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin'
      
  #     - name: Remove old version
  #       run: |
  #         ssh ${{ secrets.STAGING_USER }}@${{ secrets.STAGING_IP_ADDR }} 'sudo docker rm -vf ${{ env.DOCKER_CONTAINER_NAME }}'

  #     - name: Pull images
  #       run: |
  #         ssh ${{ secrets.STAGING_USER }}@${{ secrets.STAGING_IP_ADDR }} 'sudo docker pull ${{ env.DOCKER_IMAGE }}'
      
  #     - name: Setup new version
  #       run: |
  #         ssh ${{ secrets.STAGING_USER }}@${{ secrets.STAGING_IP_ADDR }} 'sudo docker run -d --name ${{ env.DOCKER_CONTAINER_NAME }} -p 8080:8080 -e FLASK_APP=${{ secrets.FLASK_APP }} -e FLASK_DEBUG=${{ secrets.FLASK_DEBUG }} -e GUNICORN_BIND=${{ secrets.GUNICORN_BIND }} -e PORT=${{ secrets.PORT }} -e DATABASE_URI=${{ secrets.DATABASE_URI }} --network ${{ env.DOCKER_NETWORK }} ${{ env.DOCKER_IMAGE }}'
      
    
  # deploy-to-production:
  #   needs: [push, deploy-to-staging]
  #   runs-on: self-hosted
  #   environment:
  #     name: production
  #     url: http://ec2-54-254-129-220.ap-southeast-1.compute.amazonaws.com
  #   steps:
  #     - name: Login to Docker hub
  #       run: |
  #         ssh ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_IP_ADDR }} 'echo "${{ secrets.DOCKER_PASSWORD }}" | sudo docker login -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin'
      
  #     - name: Remove old version
  #       run: |
  #         ssh ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_IP_ADDR }} 'sudo docker rm -vf ${{ env.DOCKER_CONTAINER_NAME }}'

  #     - name: Pull images
  #       run: |
  #         ssh ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_IP_ADDR }} 'sudo docker pull ${{ env.DOCKER_IMAGE }}'
      
  #     - name: Setup new version
  #       run: |
  #         ssh ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_IP_ADDR }} 'sudo docker run -d --name ${{ env.DOCKER_CONTAINER_NAME }} -p 8080:8080 -e FLASK_APP=${{ secrets.FLASK_APP }} -e FLASK_DEBUG=${{ secrets.FLASK_DEBUG }} -e GUNICORN_BIND=${{ secrets.GUNICORN_BIND }} -e PORT=${{ secrets.PORT }} -e DATABASE_URI=${{ secrets.DATABASE_URI }} --network ${{ env.DOCKER_NETWORK }} ${{ env.DOCKER_IMAGE }}'
  #   if: github.event_name == 'workflow_dispatch'  
      



    # # Required services    
    # services:
    #   # Label used to access the service container
    #   redis:
    #     # Docker Hub image
    #     image: redis
    #     # Set health checks to wait until redis has started
    #     options: >-
    #       --health-cmd "redis-cli ping"
    #       --health-interval 10s
    #       --health-timeout 5s
    #       --health-retries 5

    # # Steps for the build
    # steps:
    #   - name: Checkout
    #     uses: actions/checkout@v3
            
    #   - name: Install dependencies
    #     run: |
    #       python -m pip install poetry
    #       poetry config virtualenvs.create false
    #       poetry lock --no-update
    #       poetry install

    #   - name: Linting
    #     run: |
    #       # stop the build if there are Python syntax errors or undefined names
    #       flake8 service tests --count --select=E9,F63,F7,F82 --show-source --statistics
    #       # test for complexity. The GitHub editor is 127 chars wide
    #       flake8 service tests --count --max-complexity=10 --max-line-length=127 --statistics
    #       # Run pylint to catch other PEP8 errors
    #       pylint service tests --max-line-length=127

    #   - name: Run unit tests with PyTest
    #     run: pytest --pspec --cov=service --cov-fail-under=95
    #     env:
    #       DATABASE_URI: "redis://redis:6379"

    #   # Create a CODECOV_TOKEN in Settings->Secrets and variables->Actions
    #   # and then uncomment the following 4 lines during hands-on lab
      
    #   # - name: Upload coverage reports to Codecov
    #   #   uses: codecov/codecov-action@v3.1.4
    #   #   with:
    #   #     token: ${{ secrets.CODECOV_TOKEN }} 
  
